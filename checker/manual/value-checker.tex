\htmlhr
\chapter{Constant Value Checker\label{value-checker}}

The Constant Value Checker is a constant propagation analysis: for
each variable, it determines whether that variable's value can be
known at compile time.

There are two ways to run the Constant Value Checker.
Typically, it is automatically run by another type checker.
When using the Value Checker as part of another checker, the
statically-executable.astub file in the Value Checker directory must
be passed as a stub file for the checker.

Alternately, it is also possible to run just the Value Checker, by
supplying the \\
\code{-processor org.checkerframework.checker.value.ValueChecker} \\
command-line option to javac.


\section{Annotations\label{value-checker-annotations}}

The Constant Value Checker comes with type annotations for indicating the
value of an expression (Section~\ref{value-checker-type-annotations}), and
method annotations for indicating methods that the Value Checker can execute.
(Section~\ref{staticallyexecutable-annotation}).


\subsection{Type Annotations\label{value-checker-type-annotations}}

Typically, the programmer does not write any type annotations.  Rather, the
type annotations are inferred by the Value Checker.

It is permitted to write type annotations, and this section describes them.
Each type annotation is parameterized by a set of values, and its meaning
is that at run time, the annotated expression's value will be one of the
given values.  For example, an expression of type 
\<\refqualclass{checker/value/qual}{StringValue}("a", "b")> must be
\<"a">, \<"b">, or \<null> at run time.
There is also an \refqualclass{checker/value/qual}{UnknownVal} annotation,
meaning that the expression's value is not known at compile time, and 
\refqualclass{checker/value/qual}{BottomVal}, meaning that the expression
is dead or always has the value \<null>.

Figure~\ref{fig-value-hierarchy} lists all the annotations and shows their
subtyping relationships.
For two annotations of the same type, subtypes have a smaller set of
possible values, as also shown in the figure.

In addition to the hierarchy shown above, an annotation is also
considered a subtype of another annotation if its value array is a
subset of the value array of the other annotation (see
Figure~\ref{fig-value-subtype}). This allows the possible values of
variables to continue to be statically evaluated even when code branches cannot be
predicted at compile-time as in Figure~\ref{fig-value-multivalue}.


\begin{figure}
\begin{center}
\includeimagenocentering{value-hierarchy}{3.5cm}
\qquad\qquad
\includeimagenocentering{value-subtype}{1.8cm}
%BEGIN LATEX
\vspace{-1.5\baselineskip}
%END LATEX
\end{center}

\caption{The type qualifier hierarchy of the Value Checker
annotations. Qualifiers in gray are used
internally by the type system but should never be written by a
programmer.  On the right is an example of the subtyping relationship
between two annotations of the same type.}
\label{fig-value-hierarchy}
\end{figure}

Each annotation's parameters indicate all the possible values for the
run-time value.  This set is limited to 10 entries for
performance reasons. Therefore, if a variable, due to program logic,
could be more than 10 different values at any given point the Value
Checker gives up and it is annotated as
\refqualclass{checker/value/qual}{UnknownVal} instead.

\begin{figure}
\begin{Verbatim}
public void foo(boolean b) {
   int i = 1;     // i is @IntVal({1})
   if (b) {  
      i = 2;      // i is now @IntVal({2})
   }        
   // i is now @IntVal({1,2})
   
   i = i + 1;     // i is now @IntVal({2,3})
}
\end{Verbatim}
\caption{An example of the Constant Value Checker accumulating possible values
    of a variable.}
\label{fig-value-multivalue}
\end{figure}

The third subtyping relationship among the value annotations is the
hierarchy of numeric value types. If two annotations satisfy the
subset relationship described above and one of them is numerically a
less precise type than the other it will be automatically ``casted''
up to the type of the other. The full extent of this subtyping is
shown in Figure~\ref{fig-value-subtyping}.

\begin{figure}
\includeimage{value-subtyping}{3cm}
\caption{Subtyping of different numeric value annotations.}
\label{fig-value-subtyping}
\end{figure}

\subsection{Compile-time execution of expressions\label{staticallyexecutable-annotation}}

Whenever all the operands of an expression are compile-time constants, the
Constant Value Checker attempts to execute the expression.  The purpose of
this is to give the expression a type annotation indicating its possible
values.  This is independent of any optimizations performed by the compiler
and does not affect the code that is generated.

The Constant Value Checker statically executes the use of operators that do
not throw exceptions (e.g., \<+>, \<->, \code{<\relax<}, \<!=>), and also
calls to methods annotated with
\refqualclass{checker/value/qual}{StaticallyExecutable}.

\begin{figure}
\begin{Verbatim}
public void @StaticallyExeutable @Pure foo(int a, int b){
       return (a + b);
}

public void bar() {
       int a = 5; // a is @IntVal({5})
       int b = 4; // b is @IntVal({4})
       @IntVal({9}) c = foo(a, b); 
}
\end{Verbatim}
\caption{An example of using the
  \refqualclass{checker/value/qual}{StaticallyExecutable} annotation to
  continue constant propagation through a method call.}
\label{fig-staticallyexecutable}
\end{figure}

A \<@StaticallyExecutable> method must
be \refqualclass{dataflow/qual}{Pure} (side-effect-free and
deterministic).

Additionally, a \<@StaticallyExecutable> method and any method it calls must be on
the classpath for the compiler because they are reflectively called at
compile-time to perform the constant value analysis.


\section{Warnings\label{value-checker-warnings}}

The Value Checker may issue warnings, mostly based on failing to
resolve methods marked as @StaticallyExecutable but which were not able to be
resolved when the checker was run. These will be displayed as warnings when
the checker is run but the only negative effect is that the return
value of the function will be @UnknownVal instead of being able to be
resolved to a specific value annotation.


%%  LocalWords:  9cm UnknownVal 5cm StringValue BottomVal 9cm 5cm
%  LocalWords:  StaticallyExecutable
